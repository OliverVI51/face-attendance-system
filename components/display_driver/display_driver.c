#include "display_driver.h"
#include "driver/spi_master.h"
#include "driver/gpio.h"
#include "driver/ledc.h"
#include "esp_lcd_panel_io.h"
#include "esp_lcd_panel_vendor.h"
#include "esp_lcd_panel_ops.h"
#include "esp_log.h"
#include <string.h>
#include <stdlib.h>

static const char *TAG = "DISPLAY";

// --- GMT147SPI (1.47") Physical Calibration ---
// Based on screen test results
#define GMT147_OFFSET_X 0
#define GMT147_OFFSET_Y 34

struct display_driver {
    esp_lcd_panel_handle_t panel_handle;
    int h_res;
    int v_res;
    int bl_pin;
};

// --- CUSTOM 8x8 BITMAP FONT ---
// ASCII 32 (' ') to 127 (DEL)
static const uint8_t font8x8[96][8] = {
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // 32 ' '
  {0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // 33 '!'
  {0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00}, // 34 '"'
  {0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00}, // 35 '#'
  {0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00}, // 36 '$'
  {0x00,0xC6,0xCC,0x18,0x30,0x66,0xC6,0x00}, // 37 '%'
  {0x38,0x6C,0x38,0x76,0xDC,0xCC,0x76,0x00}, // 38 '&'
  {0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00}, // 39 '''
  {0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x00}, // 40 '('
  {0x60,0x30,0x18,0x18,0x18,0x30,0x60,0x00}, // 41 ')'
  {0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // 42 '*'
  {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00}, // 43 '+'
  {0x00,0x00,0x00,0x00,0x18,0x18,0x0C,0x00}, // 44 ','
  {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00}, // 45 '-'
  {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00}, // 46 '.'
  {0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00}, // 47 '/'
  {0x7C,0xC6,0xCE,0xD6,0xE6,0xC6,0x7C,0x00}, // 48 '0'
  {0x30,0x70,0x30,0x30,0x30,0x30,0xFC,0x00}, // 49 '1'
  {0x78,0xCC,0x0C,0x38,0x60,0xCC,0xFC,0x00}, // 50 '2'
  {0x78,0xCC,0x0C,0x38,0x0C,0xCC,0x78,0x00}, // 51 '3'
  {0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x1E,0x00}, // 52 '4'
  {0xFC,0xC0,0xF8,0x0C,0x0C,0xCC,0x78,0x00}, // 53 '5'
  {0x38,0x60,0xC0,0xF8,0xCC,0xCC,0x78,0x00}, // 54 '6'
  {0xFC,0xCC,0x0C,0x18,0x30,0x30,0x30,0x00}, // 55 '7'
  {0x78,0xCC,0xCC,0x78,0xCC,0xCC,0x78,0x00}, // 56 '8'
  {0x78,0xCC,0xCC,0x7C,0x0C,0x18,0x70,0x00}, // 57 '9'
  {0x00,0x18,0x18,0x00,0x18,0x18,0x00,0x00}, // 58 ':'
  {0x00,0x18,0x18,0x00,0x18,0x18,0x0C,0x00}, // 59 ';'
  {0x18,0x30,0x60,0xC0,0x60,0x30,0x18,0x00}, // 60 '<'
  {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00}, // 61 '='
  {0x60,0x30,0x18,0x0C,0x18,0x30,0x60,0x00}, // 62 '>'
  {0x78,0xCC,0x0C,0x18,0x30,0x00,0x30,0x00}, // 63 '?'
  {0x7C,0xC6,0xDE,0xDE,0xDE,0xC0,0x78,0x00}, // 64 '@'
  {0x30,0x78,0xCC,0xCC,0xFC,0xCC,0xCC,0x00}, // 65 'A'
  {0xFC,0x66,0x66,0x7C,0x66,0x66,0xFC,0x00}, // 66 'B'
  {0x3C,0x66,0xC0,0xC0,0xC0,0x66,0x3C,0x00}, // 67 'C'
  {0xF8,0x6C,0x66,0x66,0x66,0x6C,0xF8,0x00}, // 68 'D'
  {0xFE,0x62,0x68,0x78,0x68,0x62,0xFE,0x00}, // 69 'E'
  {0xFE,0x62,0x68,0x78,0x68,0x60,0xF0,0x00}, // 70 'F'
  {0x3C,0x66,0xC0,0xC0,0xCE,0x66,0x3E,0x00}, // 71 'G'
  {0xCC,0xCC,0xCC,0xFC,0xCC,0xCC,0xCC,0x00}, // 72 'H'
  {0x78,0x30,0x30,0x30,0x30,0x30,0x78,0x00}, // 73 'I'
  {0x1E,0x0C,0x0C,0x0C,0xCC,0xCC,0x78,0x00}, // 74 'J'
  {0xE6,0x66,0x6C,0x78,0x6C,0x66,0xE6,0x00}, // 75 'K'
  {0xF0,0x60,0x60,0x60,0x62,0x66,0xFE,0x00}, // 76 'L'
  {0xC6,0xEE,0xFE,0xD6,0xC6,0xC6,0xC6,0x00}, // 77 'M'
  {0xC6,0xE6,0xF6,0xDE,0xCE,0xC6,0xC6,0x00}, // 78 'N'
  {0x38,0x6C,0xC6,0xC6,0xC6,0x6C,0x38,0x00}, // 79 'O'
  {0xFC,0x66,0x66,0x7C,0x60,0x60,0xF0,0x00}, // 80 'P'
  {0x78,0xCC,0xCC,0xCC,0xDC,0x78,0x1C,0x00}, // 81 'Q'
  {0xFC,0x66,0x66,0x7C,0x6C,0x66,0xE6,0x00}, // 82 'R'
  {0x7C,0xC0,0xC0,0x78,0x0C,0x0C,0xF8,0x00}, // 83 'S'
  {0xFC,0xB4,0x30,0x30,0x30,0x30,0x78,0x00}, // 84 'T'
  {0xCC,0xCC,0xCC,0xCC,0xCC,0xCC,0xFC,0x00}, // 85 'U'
  {0xCC,0xCC,0xCC,0xCC,0xCC,0x78,0x30,0x00}, // 86 'V'
  {0xC6,0xC6,0xC6,0xD6,0xFE,0xEE,0xC6,0x00}, // 87 'W'
  {0xC6,0xC6,0x6C,0x38,0x38,0x6C,0xC6,0x00}, // 88 'X'
  {0xCC,0xCC,0xCC,0x78,0x30,0x30,0x78,0x00}, // 89 'Y'
  {0xFE,0xC6,0x8C,0x18,0x32,0x66,0xFE,0x00}, // 90 'Z'
  {0x78,0x60,0x60,0x60,0x60,0x60,0x78,0x00}, // 91 '['
  {0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00}, // 92 '\'
  {0x78,0x18,0x18,0x18,0x18,0x18,0x78,0x00}, // 93 ']'
  {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00}, // 94 '^'
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // 95 '_'
  {0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00}, // 96 '`'
  {0x00,0x00,0x78,0x0C,0x7C,0xCC,0x76,0x00}, // 97 'a'
  {0xE0,0x60,0x7C,0x66,0x66,0x66,0xDC,0x00}, // 98 'b'
  {0x00,0x00,0x7C,0xC6,0xC0,0xC6,0x7C,0x00}, // 99 'c'
  {0x1C,0x0C,0x7C,0xCC,0xCC,0xCC,0x76,0x00}, // 100 'd'
  {0x00,0x00,0x7C,0xC6,0xFE,0xC0,0x7C,0x00}, // 101 'e'
  {0x3C,0x66,0x60,0xF0,0x60,0x60,0xF0,0x00}, // 102 'f'
  {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0xF8}, // 103 'g'
  {0xE0,0x60,0x6C,0x76,0x66,0x66,0xE6,0x00}, // 104 'h'
  {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00}, // 105 'i'
  {0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0xCC,0x78}, // 106 'j'
  {0xE0,0x60,0x66,0x6C,0x78,0x6C,0xE6,0x00}, // 107 'k'
  {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00}, // 108 'l'
  {0x00,0x00,0xEC,0xFE,0xD6,0xD6,0xC6,0x00}, // 109 'm'
  {0x00,0x00,0xDC,0x66,0x66,0x66,0x66,0x00}, // 110 'n'
  {0x00,0x00,0x78,0xCC,0xCC,0xCC,0x78,0x00}, // 111 'o'
  {0x00,0x00,0xDC,0x66,0x66,0x7C,0x60,0xF0}, // 112 'p'
  {0x00,0x00,0x76,0xCC,0xCC,0x7C,0x0C,0x1F}, // 113 'q'
  {0x00,0x00,0xDC,0x76,0x60,0x60,0xF0,0x00}, // 114 'r'
  {0x00,0x00,0x7E,0xC0,0x78,0x06,0xFC,0x00}, // 115 's'
  {0x10,0x30,0x7C,0x30,0x30,0x36,0x1C,0x00}, // 116 't'
  {0x00,0x00,0xCC,0xCC,0xCC,0xCC,0x76,0x00}, // 117 'u'
  {0x00,0x00,0xCC,0xCC,0xCC,0x78,0x30,0x00}, // 118 'v'
  {0x00,0x00,0xC6,0xD6,0xD6,0xFE,0x6C,0x00}, // 119 'w'
  {0x00,0x00,0xC6,0x6C,0x38,0x6C,0xC6,0x00}, // 120 'x'
  {0x00,0x00,0xCC,0xCC,0xCC,0x7C,0x0C,0xF8}, // 121 'y'
  {0x00,0x00,0xFE,0x4C,0x18,0x32,0xFE,0x00}, // 122 'z'
  {0x0C,0x18,0x18,0x30,0x18,0x18,0x0C,0x00}, // 123 '{'
  {0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // 124 '|'
  {0x30,0x18,0x18,0x0C,0x18,0x18,0x30,0x00}, // 125 '}'
  {0x00,0x00,0x32,0x1C,0x08,0x00,0x00,0x00}, // 126 '~'
  {0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF}  // 127 (Block)
};

esp_err_t display_init(const display_config_t *config, display_handle_t *handle) {
    ESP_LOGI(TAG, "Initializing ST7789 (GMT147SPI)");
    
    display_handle_t h = malloc(sizeof(struct display_driver));
    if (!h) {
        return ESP_ERR_NO_MEM;
    }
    
    h->h_res = config->h_res;
    h->v_res = config->v_res;
    h->bl_pin = config->bl_pin;
    
    // Configure backlight
    gpio_config_t bl_gpio_config = {
        .mode = GPIO_MODE_OUTPUT,
        .pin_bit_mask = 1ULL << config->bl_pin
    };
    ESP_ERROR_CHECK(gpio_config(&bl_gpio_config));
    gpio_set_level(config->bl_pin, 1);
    
    // Configure SPI bus
    spi_bus_config_t buscfg = {
        .mosi_io_num = config->mosi_pin,
        .miso_io_num = -1,
        .sclk_io_num = config->sclk_pin,
        .quadwp_io_num = -1,
        .quadhd_io_num = -1,
        // Buffer enough for full screen to prevent tearing/slowness
        .max_transfer_sz = config->h_res * config->v_res * sizeof(uint16_t) + 100,
    };
    ESP_ERROR_CHECK(spi_bus_initialize(config->spi_host, &buscfg, SPI_DMA_CH_AUTO));
    
    // Configure LCD panel IO
    esp_lcd_panel_io_handle_t io_handle = NULL;
    esp_lcd_panel_io_spi_config_t io_config = {
        .cs_gpio_num = config->cs_pin,
        .dc_gpio_num = config->dc_pin,
        .spi_mode = 0,
        .pclk_hz = config->pixel_clock_hz,
        .trans_queue_depth = 10,
        .lcd_cmd_bits = 8,
        .lcd_param_bits = 8,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_io_spi((esp_lcd_spi_bus_handle_t)config->spi_host, &io_config, &io_handle));
    
    // Configure LCD panel (BGR Color Order)
    esp_lcd_panel_dev_config_t panel_config = {
        .reset_gpio_num = config->rst_pin,
        .rgb_endian = LCD_RGB_ENDIAN_BGR, // Corrected to BGR
        .bits_per_pixel = 16,
    };
    ESP_ERROR_CHECK(esp_lcd_new_panel_st7789(io_handle, &panel_config, &h->panel_handle));
    
    // Initialize panel
    ESP_ERROR_CHECK(esp_lcd_panel_reset(h->panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_init(h->panel_handle));
    ESP_ERROR_CHECK(esp_lcd_panel_invert_color(h->panel_handle, true));
    
    // Set Orientation: Landscape
    ESP_ERROR_CHECK(esp_lcd_panel_swap_xy(h->panel_handle, true));
    
    // FIX: Enable X-Mirror to write Left-to-Right
    ESP_ERROR_CHECK(esp_lcd_panel_mirror(h->panel_handle, true, false)); 
    
    // Set Gap: X=0, Y=34 (Correct for Landscape)
    ESP_ERROR_CHECK(esp_lcd_panel_set_gap(h->panel_handle, GMT147_OFFSET_X, GMT147_OFFSET_Y));
    
    // Turn on display
    ESP_ERROR_CHECK(esp_lcd_panel_disp_on_off(h->panel_handle, true));
    
    *handle = h;
    ESP_LOGI(TAG, "Display initialized");
    
    // Clear screen to Black
    display_clear(h, COLOR_BLACK);
    
    return ESP_OK;
}

esp_err_t display_clear(display_handle_t handle, uint16_t color) {
    // Fill screen in chunks
    int chunk_height = 20; 
    uint16_t *buffer = malloc(handle->h_res * chunk_height * sizeof(uint16_t));
    if (!buffer) return ESP_ERR_NO_MEM;
    
    // Swap bytes for SPI
    uint16_t color_swapped = (color >> 8) | (color << 8);
    for (int i = 0; i < handle->h_res * chunk_height; i++) {
        buffer[i] = color_swapped;
    }
    
    for (int y = 0; y < handle->v_res; y += chunk_height) {
        int h = chunk_height;
        if (y + h > handle->v_res) h = handle->v_res - y;
        esp_lcd_panel_draw_bitmap(handle->panel_handle, 0, y, handle->h_res, y + h, buffer);
    }
    
    free(buffer);
    return ESP_OK;
}

// Optimized Text Drawing (Buffered)
esp_err_t display_draw_text(display_handle_t handle, int x, int y, const char *text, uint16_t fg_color, uint16_t bg_color) {
    int len = strlen(text);
    int char_width = 8;
    int char_height = 16;  // 2x Scale
    
    uint16_t *buffer = malloc(char_width * 2 * char_height * sizeof(uint16_t));
    if (!buffer) return ESP_ERR_NO_MEM;
    
    uint16_t fg_swapped = (fg_color >> 8) | (fg_color << 8);
    uint16_t bg_swapped = (bg_color >> 8) | (bg_color << 8);

    for (int i = 0; i < len; i++) {
        char c = text[i];
        if (c < 32 || c > 127) c = 127; // Use block for unknown chars
        const uint8_t *glyph = font8x8[c - 32];
        
        int draw_x = x + i * (char_width * 2);
        
        int idx = 0;
        for (int row = 0; row < 8; row++) {
            for (int dup_y = 0; dup_y < 2; dup_y++) { 
                for (int col = 0; col < 8; col++) {
                     // Check bits MSB left (7-col)
                     uint16_t color = (glyph[row] & (1 << (7 - col))) ? fg_swapped : bg_swapped;
                     buffer[idx++] = color;
                     buffer[idx++] = color;
                }
            }
        }
        
        if (draw_x + 16 <= handle->h_res && y + 16 <= handle->v_res) {
            esp_lcd_panel_draw_bitmap(handle->panel_handle, draw_x, y, draw_x + 16, y + 16, buffer);
        }
    }
    
    free(buffer);
    return ESP_OK;
}

// Optimized Large Text Drawing (3x Scale)
// Reduces size to 24x24 pixels (Scale 3) to fit screen better.
// Keeps the robust "strip" rendering to prevent glitches.
esp_err_t display_draw_text_large(display_handle_t handle, int x, int y, const char *text, uint16_t fg_color, uint16_t bg_color) {
    if (!handle || !text) return ESP_ERR_INVALID_ARG;

    int len = strlen(text);
    int char_width = 8;
    
    // --- CHANGE: Scale reduced from 4 to 3 ---
    int scale = 3; 
    // New Size: 24 pixels wide, 24 pixels tall
    int char_real_width = char_width * scale; 
    
    // We break the character into 4 strips to ensure safe DMA transmission
    // Each strip handles 2 rows of the 8x8 font.
    // Strip height = 2 rows * scale 3 = 6 pixels high.
    int font_rows_per_strip = 2;
    int strip_height = font_rows_per_strip * scale; 
    
    // Buffer size: 24 width * 6 height * 2 bytes = 288 bytes (Very safe for stack/DMA)
    int buffer_size = char_real_width * strip_height * sizeof(uint16_t);

    uint16_t fg_swapped = (fg_color >> 8) | (fg_color << 8);
    uint16_t bg_swapped = (bg_color >> 8) | (bg_color << 8);

    for (int i = 0; i < len; i++) {
        char c = text[i];
        if (c < 32 || c > 127) c = 127;
        const uint8_t *glyph = font8x8[c - 32];
        
        int draw_x = x + i * char_real_width;

        // Skip if completely out of bounds
        if (draw_x >= handle->h_res || y >= handle->v_res || draw_x + char_real_width < 0) {
            continue;
        }

        // Draw in 4 strips (covering the 8 rows of the font)
        for (int strip = 0; strip < 4; strip++) {
            int current_y = y + (strip * strip_height);
            
            // Boundary check for Y
            if (current_y >= handle->v_res) break; 

            // DMA-capable memory allocation
            uint16_t *buffer = heap_caps_malloc(buffer_size, MALLOC_CAP_DMA | MALLOC_CAP_INTERNAL);
            if (!buffer) {
                ESP_LOGE(TAG, "No mem for text strip");
                return ESP_ERR_NO_MEM;
            }

            int idx = 0;
            // Determine which font rows this strip covers
            int start_row = strip * font_rows_per_strip;
            int end_row = start_row + font_rows_per_strip;

            for (int row = start_row; row < end_row; row++) {
                // Vertical Scale 
                for (int dup_y = 0; dup_y < scale; dup_y++) {
                    for (int col = 0; col < 8; col++) {
                        uint16_t color = (glyph[row] & (1 << (7 - col))) ? fg_swapped : bg_swapped;
                        // Horizontal Scale 
                        for(int dup_x = 0; dup_x < scale; dup_x++) {
                            buffer[idx++] = color;
                        }
                    }
                }
            }

            // Draw this strip
            if (draw_x + char_real_width <= handle->h_res && current_y + strip_height <= handle->v_res) {
                 esp_lcd_panel_draw_bitmap(handle->panel_handle, draw_x, current_y, draw_x + char_real_width, current_y + strip_height, buffer);
            }
            
            free(buffer);
        }
    }
    
    return ESP_OK;
}

esp_err_t display_fill_rect(display_handle_t handle, int x, int y, int w, int h, uint16_t color) {
    if (x < 0 || y < 0 || x + w > handle->h_res || y + h > handle->v_res) return ESP_ERR_INVALID_ARG;
    
    uint16_t *buffer = malloc(w * h * sizeof(uint16_t));
    if (!buffer) return ESP_ERR_NO_MEM;
    
    uint16_t color_swapped = (color >> 8) | (color << 8);
    for (int i = 0; i < w * h; i++) buffer[i] = color_swapped;
    
    esp_lcd_panel_draw_bitmap(handle->panel_handle, x, y, x + w, y + h, buffer);
    free(buffer);
    return ESP_OK;
}

esp_err_t display_set_backlight(display_handle_t handle, uint8_t brightness) {
    if (brightness > 100) brightness = 100;
    gpio_set_level(handle->bl_pin, brightness > 0 ? 1 : 0);
    return ESP_OK;
}

esp_lcd_panel_handle_t display_get_panel_handle(display_handle_t handle) {
    return handle->panel_handle;
}